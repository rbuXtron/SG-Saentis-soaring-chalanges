// /public/js/services/badge-season-calculator-final.js
/**
 * SG S√§ntis Cup - Finaler Badge Season Calculator
 * 
 * Berechnet Badges der Saison 2024/2025 korrekt:
 * - Nur Badges mit created >= 1.10.2024 z√§hlen
 * - Multi-Level Badges werden durch R√ºckw√§rtssuche verifiziert
 * - Punkte = Anzahl der Badge-Icons bei Multi-Level Badges
 */

import { apiClient } from './weglide-api-service.js';

const SEASON_START = new Date('2024-10-01T00:00:00');
const DEBUG_MODE = true;

/**
 * Hauptfunktion: Berechnet Season Badges
 */
export async function calculateSeasonBadgesFinal(userId, pilotName) {
  console.log(`\nüèÖ Berechne Saison 24/25 Badges f√ºr ${pilotName} (ID: ${userId})`);
  
  try {
    // 1. Lade ALLE Badges des Users
    const allUserBadges = await apiClient.fetchUserAchievements(userId);
    
    if (!allUserBadges || allUserBadges.length === 0) {
      console.log(`   ‚Üí Keine Badges gefunden`);
      return createEmptyResult(pilotName, userId);
    }
    
    console.log(`   ‚Üí ${allUserBadges.length} Badges insgesamt gefunden`);
    
    // 2. Filtere nur Badges aus der aktuellen Saison (created >= 1.10.2024)
    const seasonBadges = allUserBadges.filter(badge => {
      const createdDate = new Date(badge.created);
      return createdDate >= SEASON_START;
    });
    
    console.log(`   ‚Üí ${seasonBadges.length} Badges in Saison 24/25`);
    
    if (seasonBadges.length === 0) {
      return createEmptyResult(pilotName, userId);
    }
    
    // 3. Separiere Single-Level und Multi-Level Badges
    const singleLevelBadges = [];
    const multiLevelBadges = [];
    
    seasonBadges.forEach(badge => {
      const points = badge.points || 1;
      
      if (points > 1) {
        // Multi-Level Badge (points > 1)
        multiLevelBadges.push({
          ...badge,
          isMultiLevel: true,
          originalPoints: points
        });
        console.log(`   üìä Multi-Level: ${badge.badge?.name || badge.badge_id} = ${points} Punkte`);
      } else {
        // Single-Level Badge (points = 1)
        singleLevelBadges.push({
          ...badge,
          isMultiLevel: false,
          finalPoints: 1
        });
      }
    });
    
    console.log(`   ‚Üí ${multiLevelBadges.length} Multi-Level Badges zum Pr√ºfen`);
    console.log(`   ‚Üí ${singleLevelBadges.length} Single-Level Badges (z√§hlen voll)`);
    
    // 4. Verarbeite Multi-Level Badges durch R√ºckw√§rtssuche
    const processedMultiLevelBadges = [];
    let historicalFlights = []; // HIER: Variable au√üerhalb des if-Blocks definieren
    
    if (multiLevelBadges.length > 0) {
      console.log(`\n   üîÑ Starte R√ºckw√§rtssuche f√ºr Multi-Level Badges...`);
      
      // Lade User-Fl√ºge f√ºr R√ºckw√§rtssuche
      historicalFlights = await loadHistoricalFlights(userId);
      console.log(`   ‚Üí ${historicalFlights.length} historische Fl√ºge gefunden`);
      
      // Map zum Tracken welche Badges bereits gefunden wurden
      const foundBadgesMap = new Map();
      
      // Durchsuche Fl√ºge r√ºckw√§rts
      for (const flight of historicalFlights) {
        // Pr√ºfe ob alle Multi-Level Badges bereits gefunden wurden
        if (foundBadgesMap.size === multiLevelBadges.length) {
          console.log(`   ‚úÖ Alle ${multiLevelBadges.length} Multi-Level Badges verifiziert - Suche beendet`);
          break;
        }
        
        // Lade Flugdetails
        try {
          const flightDetails = await apiClient.fetchFlightDetails(flight.id);
          if (!flightDetails || !flightDetails.achievements) continue;
          
          // Pr√ºfe Achievements im Flug
          for (const achievement of flightDetails.achievements) {
            // Suche nach diesem Badge-Typ in unseren Multi-Level Badges
            const matchingBadge = multiLevelBadges.find(
              mb => mb.badge_id === achievement.badge_id && !foundBadgesMap.has(mb.badge_id)
            );
            
            if (matchingBadge) {
              // Badge in Vergangenheit gefunden!
              const oldPoints = achievement.points || 1;
              const newPoints = matchingBadge.originalPoints;
              const seasonPoints = Math.max(0, newPoints - oldPoints);
              
              console.log(`   üîç ${matchingBadge.badge?.name || matchingBadge.badge_id}:`);
              console.log(`      Alter Stand: ${oldPoints} Punkte (${flight.scoring_date})`);
              console.log(`      Neuer Stand: ${newPoints} Punkte`);
              console.log(`      ‚Üí Saison-Punkte: ${seasonPoints}`);
              
              foundBadgesMap.set(matchingBadge.badge_id, {
                oldPoints,
                flightId: flight.id,
                flightDate: flight.scoring_date
              });
              
              // Badge mit berechneten Punkten speichern
              processedMultiLevelBadges.push({
                ...matchingBadge,
                finalPoints: seasonPoints,
                preSeasonPoints: oldPoints,
                foundInFlight: flight.id
              });
            }
          }
        } catch (error) {
          console.warn(`   ‚ö†Ô∏è Fehler beim Laden von Flug ${flight.id}:`, error.message);
          continue;
        }
      }
      
      // Verarbeite Multi-Level Badges die NICHT in der Vergangenheit gefunden wurden
      multiLevelBadges.forEach(badge => {
        if (!foundBadgesMap.has(badge.badge_id)) {
          console.log(`   ‚ú® ${badge.badge?.name || badge.badge_id}: Neu in dieser Saison = ${badge.originalPoints} Punkte`);
          processedMultiLevelBadges.push({
            ...badge,
            finalPoints: badge.originalPoints,
            preSeasonPoints: 0,
            isNew: true
          });
        }
      });
    }
    
    // 5. Erstelle finale Badge-Liste f√ºr die Saison
    const finalSeasonBadges = [];
    
    // Single-Level Badges (1 Punkt pro Badge)
    singleLevelBadges.forEach(badge => {
      finalSeasonBadges.push({
        ...badge,
        points: 1,
        type: 'single-level',
        // F√ºr UI-Kompatibilit√§t
        name: badge.badge?.name || badge.name || badge.badge_id,
        description: badge.badge?.description || badge.description || '',
        logo: badge.badge?.logo || badge.logo || null,
        achieved_at: badge.created,
        verified: true,
        season: '2024/2025'
      });
    });
    
    // Multi-Level Badges (finalPoints = berechnete Punkte)
    processedMultiLevelBadges.forEach(badge => {
      // Erstelle einen Eintrag pro Punkt
      for (let i = 0; i < badge.finalPoints; i++) {
        finalSeasonBadges.push({
          ...badge,
          points: 1,
          pointIndex: i + 1,
          totalPoints: badge.finalPoints,
          type: 'multi-level',
          // F√ºr UI-Kompatibilit√§t
          name: badge.badge?.name || badge.name || badge.badge_id,
          description: badge.badge?.description || badge.description || '',
          logo: badge.badge?.logo || badge.logo || null,
          achieved_at: badge.created,
          verified: true,
          season: '2024/2025'
        });
      }
    });
    
    // 6. Berechne Statistiken
    const stats = {
      totalSeasonBadges: finalSeasonBadges.length,
      singleLevelCount: singleLevelBadges.length,
      multiLevelCount: multiLevelBadges.length,
      multiLevelVerified: processedMultiLevelBadges.filter(b => !b.isNew).length,
      multiLevelNew: processedMultiLevelBadges.filter(b => b.isNew).length,
      totalPoints: finalSeasonBadges.length,
      badgesByMonth: {},
      topBadges: []
    };
    
    // Gruppiere nach Monat
    finalSeasonBadges.forEach(badge => {
      if (badge.created) {
        const month = new Date(badge.created).toLocaleDateString('de-DE', { 
          year: 'numeric', 
          month: 'long' 
        });
        stats.badgesByMonth[month] = (stats.badgesByMonth[month] || 0) + 1;
      }
    });
    
    // Top Badges
    const badgeCounts = {};
    finalSeasonBadges.forEach(badge => {
      const name = badge.name || badge.badge_id;
      badgeCounts[name] = (badgeCounts[name] || 0) + 1;
    });
    
    stats.topBadges = Object.entries(badgeCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([name, count]) => ({ name, count }));
    
    console.log(`\nüìä Zusammenfassung f√ºr ${pilotName}:`);
    console.log(`   ‚Üí ${stats.totalSeasonBadges} Badge-Punkte in Saison 24/25`);
    console.log(`   ‚Üí ${stats.singleLevelCount} Single-Level Badges`);
    console.log(`   ‚Üí ${stats.multiLevelCount} Multi-Level Badges`);
    console.log(`     - ${stats.multiLevelVerified} verifiziert (Punkte reduziert)`);
    console.log(`     - ${stats.multiLevelNew} neu in dieser Saison`);
    
    return {
      pilotName,
      userId,
      seasonBadges: finalSeasonBadges,
      allTimeBadges: allUserBadges,
      stats,
      // Kompatibilit√§t mit bestehendem Code
      badges: finalSeasonBadges,
      badgeCount: finalSeasonBadges.length,
      badgeCategoryCount: new Set(finalSeasonBadges.map(b => b.badge_id)).size,
      flightsAnalyzed: historicalFlights.length,
      flightsWithBadges: new Set(finalSeasonBadges.filter(b => b.flight_id).map(b => b.flight_id)).size,
      // Neue Felder f√ºr UI
      seasonBadgeCount: finalSeasonBadges.length,
      seasonBadgeTypeCount: new Set(finalSeasonBadges.map(b => b.badge_id)).size,
      allTimeBadgeCount: allUserBadges.length,
      verifiedBadgeCount: processedMultiLevelBadges.filter(b => !b.isNew).length,
      firstTimeTypes: processedMultiLevelBadges.filter(b => b.isNew).length,
      repeatedTypes: processedMultiLevelBadges.filter(b => !b.isNew).length,
      multipleOccurrences: []
    };
    
  } catch (error) {
    console.error(`‚ùå Fehler bei Badge-Berechnung:`, error);
    return createEmptyResult(pilotName, userId);
  }
}

/**
 * L√§dt historische Fl√ºge (vor Saisonbeginn)
 */
async function loadHistoricalFlights(userId) {
  const allFlights = [];
  const currentYear = new Date().getFullYear();
  
  // Lade Fl√ºge der letzten Jahre
  for (const year of [2024, 2023, 2022]) {
    try {
      const flights = await apiClient.fetchUserFlights(userId, year);
      if (Array.isArray(flights)) {
        allFlights.push(...flights);
      }
    } catch (error) {
      console.warn(`   ‚ö†Ô∏è Fehler beim Laden der Fl√ºge f√ºr ${year}:`, error.message);
    }
  }
  
  // Filtere nur Fl√ºge VOR Saisonbeginn und sortiere r√ºckw√§rts
  const historicalFlights = allFlights
    .filter(flight => new Date(flight.scoring_date || flight.takeoff_time) < SEASON_START)
    .sort((a, b) => {
      const dateA = new Date(a.scoring_date || a.takeoff_time);
      const dateB = new Date(b.scoring_date || b.takeoff_time);
      return dateB - dateA; // Neueste zuerst
    });
  
  return historicalFlights;
}

/**
 * Erstellt ein leeres Ergebnis
 */
function createEmptyResult(pilotName, userId) {
  return {
    pilotName,
    userId,
    seasonBadges: [],
    allTimeBadges: [],
    badges: [],
    badgeCount: 0,
    badgeCategoryCount: 0,
    seasonBadgeCount: 0,
    seasonBadgeTypeCount: 0,
    allTimeBadgeCount: 0,
    verifiedBadgeCount: 0,
    stats: {
      totalSeasonBadges: 0,
      singleLevelCount: 0,
      multiLevelCount: 0,
      multiLevelVerified: 0,
      multiLevelNew: 0,
      totalPoints: 0,
      badgesByMonth: {},
      topBadges: []
    },
    flightsAnalyzed: 0,
    flightsWithBadges: 0,
    firstTimeTypes: 0,
    repeatedTypes: 0,
    multipleOccurrences: []
  };
}

/**
 * Test-Funktion
 */
export async function testBadgeCalculationFinal(userId, pilotName) {
  console.log('\nüß™ TESTE FINALE BADGE-BERECHNUNG');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  
  const result = await calculateSeasonBadgesFinal(userId, pilotName);
  
  console.log('\nüìä TESTERGEBNIS:');
  console.log(`Pilot: ${result.pilotName} (ID: ${result.userId})`);
  console.log(`Badge-Punkte gesamt: ${result.badgeCount}`);
  console.log(`Verschiedene Badge-Typen: ${result.badgeCategoryCount}`);
  
  if (result.stats) {
    console.log('\nDetails:');
    console.log(`- Single-Level: ${result.stats.singleLevelCount}`);
    console.log(`- Multi-Level: ${result.stats.multiLevelCount}`);
    console.log(`  ‚Üí Verifiziert: ${result.stats.multiLevelVerified}`);
    console.log(`  ‚Üí Neu: ${result.stats.multiLevelNew}`);
  }
  
  return result;
}